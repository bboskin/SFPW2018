#lang racket

(require "mk.rkt"
         "helpers.rkt"
         "tables.rkt")

(provide substo)

#|
The language currently supported is:
Σ , Π , Trivial , Nats, Equality
|#

(defrel (free-vars exp vs)
  (gather
   (inspect exp free-vars-table in-mode)
   (condp
     ;; Symbols
     ['var (not-reserved-symbol exp) (== vs `(,exp))]
     ['var (reserved-symbol exp) (== vs '())]
     ;; Binding Locations
     ['Π
      (fresh (x A R vsA vsR vsRf)
        (== exp `(Π ([,x ,A]) ,R))
        (free-vars A vsA)
        (free-vars R vsR)
        (removo x vsR vsRf)
        (uniono vsA vsRf vs))]
     ['Σ
      (fresh (x A D vsA vsD vsDf)
        (== exp `(Σ ([,x ,A]) ,D))
        (free-vars A vsA)
        (free-vars D vsD)
        (removo x vsD vsDf)
        (uniono vsA vsDf vs))]
     ['λ
      (fresh (x b vs^)
        (== exp `(λ (,x) ,b))
       (free-vars b vs^)
       (removo x vs^ vs))]
     ;; Easy ones
     ['quote
      (fresh (s)
        (== s `(quote ,s))
        (symbolo s)
        (== vs '()))]
     ;; Pairs
     ['cons
      (fresh (a d vs-a vs-d)
        (== exp `(cons ,a ,d))
        (free-vars a vs-a)
        (free-vars d vs-d)
        (uniono vs-a vs-d vs))]
     ['car
      (fresh (pr)
        (== exp `(car ,pr))
        (free-vars pr vs))]
     ['cdr
      (fresh (pr)
        (== exp `(cdr ,pr))
        (free-vars pr vs))]
     ;; Nats
     ['add1
      (fresh (n)
        (== exp `(add1 ,n))
        (free-vars n vs))]
     ['ind-Nat
      (fresh (t m b s vt vm vb vst v1 v2)
        (== exp `(ind-Nat ,t ,m ,b ,s))
        (free-vars t vt)
        (free-vars m vm)
        (free-vars b vb)
        (free-vars s vst)
        (uniono vt vm v1)
        (uniono v1 vb v2)
        (uniono v2 vst vs))]
     ['app
      (fresh (f arg f-vs arg-vs)
        (== exp `(,f ,arg))
        (not-reserved-fn f)
        (free-vars f f-vs)
        (free-vars arg arg-vs)
        (uniono f-vs arg-vs vs))]
     ;; Equality
     ['=
      (fresh (X from to vs-X vs-from vs-to vs1)
        (== exp `(= ,X ,from ,to))
        (free-vars X vs-X)
        (free-vars from vs-from)
        (free-vars to vs-to)
        (uniono vs-X vs-from vs1)
        (uniono vs1 vs-to vs))]
     ['ind-=
      (fresh (t m b vs-t vs-m vs-b vs1)
        (== exp `(ind-= ,t ,m ,b))
        (free-vars t vs-t)
        (free-vars m vs-m)
        (free-vars b vs-b)
        (uniono vs-t vs-m vs1)
        (uniono vs1 vs-b vs))]
     ['same
      (fresh (v)
        (== exp `(same ,v))
        (free-vars v vs))]
     ['the
      (fresh (τ e τ-vs e-vs)
        (== exp `(the ,τ ,e))
        (free-vars τ τ-vs)
        (free-vars e e-vs)
        (uniono τ-vs e-vs vs))])))

(defrel (substo x a exp o)
  (gather
   (inspect exp subst-in-table in-mode)
   (inspect o subst-out-table)
   (condp
     ;; Variables and simple symbols
     ['here (== exp x) (== o a)]
     ['sym (symbolo exp) (=/= exp x) (== exp o)]
     ;; The
     ['the
      (fresh (τ e τ^ e^)
        (== exp `(the ,τ ,e))
        (== o `(the ,τ^ ,e^))
        (substo x a τ τ^)
        (substo x a e e^))]
     ;; Atoms
     ['quote
      (fresh (s)
        (symbolo s)
        (== exp `(quote ,s))
        (== exp o))]
     ;; Functions
     ['λ
      (fresh (y b b-vars a-vars)
        (== exp `(λ (,y) ,b))
        (conde
          [(== y x) (== o `(λ (,y) ,b))]
          [(=/= y x)
           (free-vars b b-vars)
           (free-vars a a-vars)
           (conde
             [(conde
                [(not-membero x b-vars)]
                [(not-membero y a-vars)])
              (fresh (o^)
                (== o `(λ (,y) ,o^))
                (substo x a b o^))]
             [(membero x b-vars)
              (membero y a-vars)
              (fresh (fr b-new o^)
                (fresh-name fr)
                (substo y fr b b-new)
                (== o `(λ (,fr) ,o^))
                (substo x a b-new o^))])]))]
     ['Π
      (fresh (y Arg R z Arg^ R^ R-vars a-vars)
        (== exp `(Π ([,y ,Arg]) ,R))
        (== o `(Π ([,z ,Arg^]) ,R^))
        (substo x a Arg Arg^)
        (conde
          [(== y x) (== R R^) (== z y)]
          [(=/= y x)
           (free-vars R R-vars)
           (free-vars a a-vars)
           (conde
             [(conde
                [(not-membero x R-vars)]
                [(not-membero y a-vars)])
              (substo x a R R^)
              (== z y)]
             [(membero x R-vars)
              (membero y a-vars)
              (fresh (fr R-new)
                (fresh-name fr)
                (== z fr)
                (substo y fr R R-new)
                (substo x a R-new R^))])]))]
     ['app
      (fresh (f arg f^ arg^)
        (== exp `(,f ,arg))
        (not-reserved-fn f)
        (== o `(,f^ ,arg^))
        (substo x a f f^)
        (substo x a arg arg^))]
     ;; Pairs
     ['Σ
      (fresh (y Arg D z Arg^ D^ D-vars a-vars)
        (== exp `(Σ ([,y ,Arg]) ,D))
        (== o `(Σ ([,z ,Arg^]) ,D^))
        (substo x a Arg Arg^)
        (conde
          [(== y x) (== D D^) (== z y)]
          [(=/= y x)
           (free-vars D D-vars)
           (free-vars a a-vars)
           (conde
             [(conde
                [(not-membero x D-vars)]
                [(not-membero y a-vars)])
              (== z y)
              (substo x a D D^)]
             [(membero x D-vars)
              (membero y a-vars)
              (fresh (fr D-new)
                (fresh-name fr)
                (== z fr)
                (substo y fr D D-new)
                (substo x a D-new D^))])]))]
     ['cons
      (fresh (ca cd ca^ cd^)
        (== exp `(cons ,ca ,cd))
        (== o `(cons ,ca^ ,cd^))
        (substo x a ca ca^)
        (substo x a cd cd^))]
     ['car
      (fresh (pr pr^)
        (== exp `(car ,pr))
        (== o `(car ,pr^))
        (substo x a pr pr^))]
     ['cdr
      (fresh (pr pr^)
        (== exp `(cdr ,pr))
        (== o `(cdr ,pr^))
        (substo x a pr pr^))]
     ;; Nats
     ['add1
      (fresh (n n^)
        (== exp `(add1 ,n))
        (== o `(add1 ,n^))
        (substo x a n n^))]
     ['ind-Nat
      (fresh (t m b s t^ m^ b^ s^)
        (== exp `(ind-Nat ,t ,m ,b ,s))
        (== o `(ind-Nat ,t^ ,m^ ,b^ ,s^))
        (substo x a t t^)
        (substo x a m m^)
        (substo x a b b^)
        (substo x a s s^))]
     ;; Equality
     ['same
      (fresh (v vo)
        (== exp `(same ,v))
        (== o `(same ,vo))
        (substo x a v vo))]
     ['=
      (fresh (X from to X^ from^ to^)
        (== exp `(= ,X ,from ,to))
        (== o `(= ,X^ ,from^ ,to^))
        (substo x a X X^)
        (substo x a from from^)
        (substo x a to to^))]
     ['ind-=
      (fresh (t m b t^ m^ b^)
        (== exp `(ind-= ,t ,m ,b))
        (== o `(ind-= ,t^ ,m^ ,b^))
        (substo x a t t^)
        (substo x a m m^)
        (substo x a b b^))])))

