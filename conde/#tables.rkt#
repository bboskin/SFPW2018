
#lang racket

(require "mk.rkt")

(provide valofo-in
         valofo-out
         ;read-back-v
         ;read-back-norm
         ;read-back-τ
         ;RBT-v
         ;RBT-n
         #;RBN-ne)

;; Groupings of Tags
(define all-exprs
  '(var the zero sole Nat Trivial Atom U quote add1 app
        same λ cons car cdr ind-Nat ind-= Π Σ =))
(define eliminators '(var car cdr app ind-Nat ind-=))
(define symbol-exprs '(zero sole Atom Nat Trivial U))
(define non-symbol-exprs
  '(the quote add1 same λ cons car cdr ind-Nat ind-= Π Σ =))
(define types '(Trivial Atom Nat Π Σ =))

;; generic predicates

;; A predicate that takes a list of possible forms, and tells if the expression
;; is one of them
(define ((exp-memv ls) e)
  (and (pair? e) (memv (car e) ls)))

;; If an expression of one of the reserved expression symobols of Pie
(define simple? (λ (x) (memv x symbol-exprs)))

;; A function to tell that a certain expression a) is ground, and a list,
;; and b) has a certain car (we can know what type of expression it is)
(define (pair-test? sym)
  (λ (x) (and (pair? x) (eqv? (car x) sym))))

;; the non-symbol forms that are handled in "synth" mode
(define synth-forms '(add1 quote the ind-Nat ind-= Π Σ = car cdr))

;; the forms that are directly handled in check mode
(define check-forms '(cons same λ))

(define (simple-type? τ)
  (member τ '(Atom Nat Trivial U)))
(define (complex-type? t)
  (and (pair? t)
       (memv (car t) '(Π Σ =))))


(define (get-constructors τ)
  (match τ
    ['Atom '(quote)]
    ['Trivial '(sole)]
    ['Nat '(zero add1)]
    ['U '(Trivial Atom Nat Π Σ =)]
    [`(Π ([,x ,A]) ,R) '(λ)]
    [`(Σ ([,x ,A]) ,D) '(cons)]
    [`(= ,X ,from ,to) '(same)]
    [else '()]))


;;;;;;;;;;;;;;;;
;;Tables used in NbE.rkt

;; valofo

;; read-backo
(define (in-type? e τ)
  (let ([cs (get-constructors τ)])
    (or (memv e cs)
        (and (pair? e)
             (member (car e) cs)))))

(define (read-back-v v)
  (match v
    [`(THE ,t ,e) '(the)]
    [`(NEU ,t ,e) '(neutral)]
    [(? var?) '(use-out)]
    [else '()]))
    
(define (read-back-τ t)
  (match t
    ['UNIVERSE '(U)]
    ['TRIVIAL '(Trivial)]
    ['NAT '(Nat)]
    ['ATOM '(Atom)]
    [`(SIGMA . ,info) '(Σ)]
    [`(EQUAL . ,info) '(=)]
    [`(PI . ,info) '(Π)]
    [(? var?) '(use-out)]
    [else '(the neutral)]))

(define (read-back-norm e)
  (let loop ([t '(Nat Trivial Atom Σ Π = U)])
    (cond
      [(null? t) '()]
      [(in-type? e (car t)) (list (car t) 'neutral 'the)]
      [else (loop (cdr t))])))
                




